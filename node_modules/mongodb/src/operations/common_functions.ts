<<<<<<< HEAD
import type { Document } from '../bson';
import type { Collection } from '../collection';
import type { Db } from '../db';
import type { ReadPreference } from '../read_preference';
import type { ClientSession } from '../sessions';
=======
import { MongoTopologyClosedError } from '../error';
import { Callback, getTopology } from '../utils';
import type { Document } from '../bson';
import type { Db } from '../db';
import type { ClientSession } from '../sessions';
import type { ReadPreference } from '../read_preference';
import type { Collection } from '../collection';
>>>>>>> 768ced843bdc2d8e095a03a448cee0f9c62c51e9

/** @public */
export interface IndexInformationOptions {
  full?: boolean;
  readPreference?: ReadPreference;
  session?: ClientSession;
}
/**
 * Retrieves this collections index info.
 *
 * @param db - The Db instance on which to retrieve the index info.
 * @param name - The name of the collection.
 */
<<<<<<< HEAD
export async function indexInformation(db: Db, name: string): Promise<any>;
export async function indexInformation(
  db: Db,
  name: string,
  options?: IndexInformationOptions
): Promise<any>;
export async function indexInformation(
  db: Db,
  name: string,
  options?: IndexInformationOptions
): Promise<any> {
  if (options == null) {
=======
export function indexInformation(db: Db, name: string, callback: Callback): void;
export function indexInformation(
  db: Db,
  name: string,
  options: IndexInformationOptions,
  callback?: Callback
): void;
export function indexInformation(
  db: Db,
  name: string,
  _optionsOrCallback: IndexInformationOptions | Callback,
  _callback?: Callback
): void {
  let options = _optionsOrCallback as IndexInformationOptions;
  let callback = _callback as Callback;
  if ('function' === typeof _optionsOrCallback) {
    callback = _optionsOrCallback as Callback;
>>>>>>> 768ced843bdc2d8e095a03a448cee0f9c62c51e9
    options = {};
  }
  // If we specified full information
  const full = options.full == null ? false : options.full;
<<<<<<< HEAD
  // Get the list of indexes of the specified collection
  const indexes = await db.collection(name).listIndexes(options).toArray();
  if (full) return indexes;

  const info: Record<string, Array<[string, unknown]>> = {};
  for (const index of indexes) {
    info[index.name] = Object.entries(index.key);
  }
  return info;
}

export function maybeAddIdToDocuments(
  coll: Collection,
  docs: Document[],
  options: { forceServerObjectId?: boolean }
): Document[];
export function maybeAddIdToDocuments(
  coll: Collection,
  docs: Document,
  options: { forceServerObjectId?: boolean }
): Document;
export function maybeAddIdToDocuments(
  coll: Collection,
  docOrDocs: Document[] | Document,
  options: { forceServerObjectId?: boolean }
): Document[] | Document {
=======

  // Did the user destroy the topology
  if (getTopology(db).isDestroyed()) return callback(new MongoTopologyClosedError());
  // Process all the results from the index command and collection
  function processResults(indexes: any) {
    // Contains all the information
    const info: any = {};
    // Process all the indexes
    for (let i = 0; i < indexes.length; i++) {
      const index = indexes[i];
      // Let's unpack the object
      info[index.name] = [];
      for (const name in index.key) {
        info[index.name].push([name, index.key[name]]);
      }
    }

    return info;
  }

  // Get the list of indexes of the specified collection
  db.collection(name)
    .listIndexes(options)
    .toArray((err, indexes) => {
      if (err) return callback(err);
      if (!Array.isArray(indexes)) return callback(undefined, []);
      if (full) return callback(undefined, indexes);
      callback(undefined, processResults(indexes));
    });
}

export function prepareDocs(
  coll: Collection,
  docs: Document[],
  options: { forceServerObjectId?: boolean }
): Document[] {
>>>>>>> 768ced843bdc2d8e095a03a448cee0f9c62c51e9
  const forceServerObjectId =
    typeof options.forceServerObjectId === 'boolean'
      ? options.forceServerObjectId
      : coll.s.db.options?.forceServerObjectId;

  // no need to modify the docs if server sets the ObjectId
  if (forceServerObjectId === true) {
<<<<<<< HEAD
    return docOrDocs;
  }

  const transform = (doc: Document): Document => {
=======
    return docs;
  }

  return docs.map(doc => {
>>>>>>> 768ced843bdc2d8e095a03a448cee0f9c62c51e9
    if (doc._id == null) {
      doc._id = coll.s.pkFactory.createPk();
    }

    return doc;
<<<<<<< HEAD
  };
  return Array.isArray(docOrDocs) ? docOrDocs.map(transform) : transform(docOrDocs);
=======
  });
>>>>>>> 768ced843bdc2d8e095a03a448cee0f9c62c51e9
}
